{
  "version": 3,
  "sources": ["../src/accordion.ts"],
  "sourcesContent": ["\n/*\n * ORBIT \n * Accordion Utilities \n * \n */ \n\n//import { AdjustTrackingUrl } from './adjust';\n\n// Global object\nwindow['Orbit'] = window['Orbit'] || {}; \nvar Orbit = window['Orbit'];\n\n\n// Define the type for an element with the necessary properties\ninterface AccordionElement extends HTMLElement {\n    // style: {\n    //     maxHeight: string | null;\n    // };\n    scrollHeight: number;\n    nextElementSibling: AccordionElement;\n}\n\nexport class Accordion {\n\n    constructor() {\n    }\n    \n    // container (holds set)\n    // - item (one item)\n    // - - header/title\n    // - - - indicator expanded/collapsed \n    // - - content panel\n\n\n    init() {\n\n        // Find accordions\n        const accordionBtns = document.querySelectorAll(\"[wfu-ui-accordion=header]\") as NodeListOf<AccordionElement>;\n\n        accordionBtns.forEach((accordion: AccordionElement) => {\n\n          accordion.onclick = function () {\n            accordion.classList.toggle(\"is-open\");\n        \n            let content = accordion.nextElementSibling;\n            console.log(content);\n        \n            if (content.style.maxHeight) {\n              //this is if the accordion is open\n              content.style.maxHeight = \"auto\";\n            } else {\n              //if the accordion is currently closed\n              content.style.maxHeight = content.scrollHeight + \"px\";\n              console.log(content.style.maxHeight);\n            }\n          };\n        });\n        \n        \n\n    }\n\n    /*\n    // Linkify images inside the rich text content\n    linkifyRichTextImages(rtfElement: Element, url: AdjustTrackingUrl): void {\n        \n        const images = rtfElement.getElementsByTagName('img');\n        \n        for (let image of images) {\n            let currentParent: ParentNode | null = image.parentNode;\n        \n            // Check if the image is already inside a link\n            let insideLink = false;\n            while (currentParent != null) {\n                if ((currentParent as Element).tagName === 'A') {\n                    insideLink = true;\n                    break;\n                }\n                currentParent = currentParent.parentNode;\n            }\n        \n            // If not inside a link, wrap it in a link\n            if (!insideLink) {\n        \n                // Allow overriding of the Adjust tracking using custom attributes \n                const imageCreative = image.getAttribute('adjust-creative') ?? url.creative;\n                const imageAdgroup = image.getAttribute('adjust-adgroup') ?? url.adgroup;\n                const imageCampaign = image.getAttribute('adjust-campaign') ?? url.campaign;\n\n                const imageTrackingUrl = new AdjustTrackingUrl(\n                    url.baseUrl, imageCreative, imageAdgroup, imageCampaign\n                ).toString();    \n                \n                let wrapper = document.createElement('a');\n                wrapper.href = imageTrackingUrl;\n                wrapper.target = \"_blank\";\n            \n                (image.parentNode as Element).insertBefore(wrapper, image);\n                wrapper.appendChild(image);\n            }\n        }\n    \n    }\n\n    // Linkify \"RISE app\" in rich text content\n    // override the url where it is already linked\n    linkifyRichTextRISE(rtfElement: Element, url: AdjustTrackingUrl): void {\n\n        const linkText: string = 'RISE\\\\s*app'; // The \"\\\\s*\" matches any amount of whitespace, including no whitespace\n    \n        // Create the tracking URL\n        const linkTrackingUrl: string = url.toString(); \n\n        const nodeIterator: NodeIterator = document.createNodeIterator(rtfElement, NodeFilter.SHOW_TEXT, null);\n        const nodes: Node[] = [];\n    \n        // Get text as a set of nodes \n        let node: Node | null;\n        while (node = nodeIterator.nextNode()) {\n            nodes.push(node);\n        }\n    \n        // Iterate through nodes\n        for (let textNode of nodes) {\n\n            // Look for regex match\n            let regex: RegExp = new RegExp(linkText, 'gi'); // 'i' makes the search case-insensitive\n            if (regex.test(textNode.textContent as string)) {\n\n                // Get parent, test if it's a link \n                let parent: Node | null = textNode.parentNode;\n                if (parent && parent.nodeName !== 'A') {\n\n                    let frag: DocumentFragment = document.createDocumentFragment();\n                    let lastIndex: number = 0;\n                    let match: RegExpExecArray | null;\n                    regex.lastIndex = 0; // Reset the regex, because \".test()\" changes the lastIndex\n    \n                    while (match = regex.exec(textNode.textContent as string)) {\n\n                        if (!textNode.textContent) continue; \n\n                        let text: string = textNode.textContent.substring(lastIndex, match.index);\n                        frag.appendChild(document.createTextNode(text));\n    \n                        let link: HTMLAnchorElement = document.createElement('a');\n                        link.textContent = match[0]; // Use the matched text, which may include extra spaces\n                        link.href = linkTrackingUrl;\n                        link.target = \"_blank\";\n                        frag.appendChild(link);\n    \n                        lastIndex = regex.lastIndex;\n                    }\n    \n                    if (!textNode.textContent) continue; \n\n                    frag.appendChild(\n                        document.createTextNode(textNode.textContent.substr(lastIndex))\n                    ); \n                    parent.replaceChild(frag, textNode);\n\n                } else if(parent) {\n\n                    // If there is a parent A already, we override its Url \n                    (parent as HTMLAnchorElement).setAttribute(\"href\", linkTrackingUrl); \n                    (parent as HTMLAnchorElement).setAttribute(\"target\", \"_blank\"); \n\n                }\n    \n            }\n\n        }\n    }\n    \n    // Linkify rich text content in one element\n    linkifyRichText(rtfElement: Element, url: AdjustTrackingUrl): void {\n    \n        this.linkifyRichTextImages(\n            rtfElement, url\n            ); \n        this.linkifyRichTextRISE(\n            rtfElement, url\n            );\n    \n    }\n    \n    // Linkify all rich text elements\n    linkifyAllRichText(elemSelector: string) { \n\n        // Create and resolve Adjust tracking url\n        var url: AdjustTrackingUrl = new AdjustTrackingUrl(); \n        if (Rise.adjustTrackingUrl)\n            url = Rise.adjustTrackingUrl(url);\n        else {\n            console.error (\"No Adjust tracking handler\");\n            return; // do not linkify \n        }\n\n        // Get all elements with the selector\n        var richTextElements = document.querySelectorAll(elemSelector);\n\n        // Exit, if nothing found\n        if(!richTextElements) {\n            console.warn (\"No rich text elements found to linkify.\");\n            return;\n        }\n\n        // Iterate through each element\n        richTextElements.forEach((element: Element) => {\n\n            if(!element)\n                return;\n\n            // Linkify the identified rich text element\n            this.linkifyRichText(element, url); \n        \n        });\n    \n    }\n*/\n}\n\n    \n    \n\n    \n    \n    \n    "],
  "mappings": ";;AAUA,SAAO,WAAW,OAAO,YAAY,CAAC;AACtC,MAAI,QAAQ,OAAO;AAYZ,MAAM,YAAN,MAAgB;AAAA,IAEnB,cAAc;AAAA,IACd;AAAA,IASA,OAAO;AAGH,YAAM,gBAAgB,SAAS,iBAAiB,2BAA2B;AAE3E,oBAAc,QAAQ,CAAC,cAAgC;AAErD,kBAAU,UAAU,WAAY;AAC9B,oBAAU,UAAU,OAAO,SAAS;AAEpC,cAAI,UAAU,UAAU;AACxB,kBAAQ,IAAI,OAAO;AAEnB,cAAI,QAAQ,MAAM,WAAW;AAE3B,oBAAQ,MAAM,YAAY;AAAA,UAC5B,OAAO;AAEL,oBAAQ,MAAM,YAAY,QAAQ,eAAe;AACjD,oBAAQ,IAAI,QAAQ,MAAM,SAAS;AAAA,UACrC;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IAIL;AAAA,EAgKJ;",
  "names": []
}
