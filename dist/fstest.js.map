{
  "version": 3,
  "sources": ["../src/fstest.ts"],
  "sourcesContent": ["\n/*\n * ORBIT \n * FS Test Utilities \n * \n */ \n\n//import { AdjustTrackingUrl } from './adjust';\n\n// Global object\nwindow['Orbit'] = window['Orbit'] || {}; \nvar Orbit = window['Orbit'];\n\nexport class FSTest {\n\n    constructor() {\n    }\n    \n    init() {\n\n        window['fsAttributes'] = window['fsAttributes'] || [];\n        window['fsAttributes'].push([\n          'cmsload',\n          (listInstances) => {\n            \n            console.log('cmsload Successfully loaded!');\n        \n            // The callback passes a `listInstances` array with all the `CMSList` instances on the page.\n            const [listInstance] = listInstances;\n        \n            console.log(listInstance); \n            if(!listInstance) return;\n            \n            console.log(\"cms lists\", listInstances?.length); \n            \n            console.log(\"cms items in list\", listInstance?.items?.length); \n            \n            if (listInstance && listInstance.items) {\n                console.log(\"item\", listInstance?.items[0]); \n                console.log(\"item\", listInstance?.items[1]); \n            }\n            \n            // The `renderitems` event runs whenever the list renders items after switching pages.\n            listInstance.on('renderitems', (renderedItems) => {\n        //      preparePageFilterData();\n              console.log(\"cmsload\", renderedItems);\n            });\n            \n            \n            listInstance.on('additems', (addedItems) => {\n              console.log(\"cmsload\", 'The following items have been added to the CMSList memory: ', addedItems);\n            });\n            \n            console.log(\"GO BABY GO!!\")\n            \n          },\n        ]); \n        \n        window['fsAttributes'] = window['fsAttributes'] || [];\n        window['fsAttributes'].push([\n          'cmsfilter',\n          (filterInstances) => {\n            \n            console.log('cmsfilter Successfully loaded!');\n        \n            // The callback passes a `listInstances` array with all the `CMSList` instances on the page.\n            const [filterInstance] = filterInstances;\n        \n            console.log(filterInstance); \n            if(!filterInstance) return;\n            \n            console.log(\"cms items in list\", filterInstance.listInstance?.items?.length); \n        \n            // The `renderitems` event runs whenever the list renders items after switching pages.\n            filterInstance.listInstance.on('renderitems', (renderedItems) => {\n        //      preparePageFilterData();\n        //      console.log(renderedItems);\n              console.log(\"cmsfilter\", renderedItems); \n            });\n            \n            \n            filterInstance.listInstance.on('additems', (addedItems) => {\n              console.log(\"cmsfilter\", 'The following items have been added to the CMSList memory: ', addedItems);\n            });\n            \n                  filterInstance.listInstance.on('switchpage', (targetPage) => {\n                console.log(\"cmsfilter\", 'switchpage event', 'The user has navigated to the page number ', targetPage);\n              });\n          },\n        ]); \n\n    }\n\n    /*\n    // Linkify images inside the rich text content\n    linkifyRichTextImages(rtfElement: Element, url: AdjustTrackingUrl): void {\n        \n        const images = rtfElement.getElementsByTagName('img');\n        \n        for (let image of images) {\n            let currentParent: ParentNode | null = image.parentNode;\n        \n            // Check if the image is already inside a link\n            let insideLink = false;\n            while (currentParent != null) {\n                if ((currentParent as Element).tagName === 'A') {\n                    insideLink = true;\n                    break;\n                }\n                currentParent = currentParent.parentNode;\n            }\n        \n            // If not inside a link, wrap it in a link\n            if (!insideLink) {\n        \n                // Allow overriding of the Adjust tracking using custom attributes \n                const imageCreative = image.getAttribute('adjust-creative') ?? url.creative;\n                const imageAdgroup = image.getAttribute('adjust-adgroup') ?? url.adgroup;\n                const imageCampaign = image.getAttribute('adjust-campaign') ?? url.campaign;\n\n                const imageTrackingUrl = new AdjustTrackingUrl(\n                    url.baseUrl, imageCreative, imageAdgroup, imageCampaign\n                ).toString();    \n                \n                let wrapper = document.createElement('a');\n                wrapper.href = imageTrackingUrl;\n                wrapper.target = \"_blank\";\n            \n                (image.parentNode as Element).insertBefore(wrapper, image);\n                wrapper.appendChild(image);\n            }\n        }\n    \n    }\n\n    // Linkify \"RISE app\" in rich text content\n    // override the url where it is already linked\n    linkifyRichTextRISE(rtfElement: Element, url: AdjustTrackingUrl): void {\n\n        const linkText: string = 'RISE\\\\s*app'; // The \"\\\\s*\" matches any amount of whitespace, including no whitespace\n    \n        // Create the tracking URL\n        const linkTrackingUrl: string = url.toString(); \n\n        const nodeIterator: NodeIterator = document.createNodeIterator(rtfElement, NodeFilter.SHOW_TEXT, null);\n        const nodes: Node[] = [];\n    \n        // Get text as a set of nodes \n        let node: Node | null;\n        while (node = nodeIterator.nextNode()) {\n            nodes.push(node);\n        }\n    \n        // Iterate through nodes\n        for (let textNode of nodes) {\n\n            // Look for regex match\n            let regex: RegExp = new RegExp(linkText, 'gi'); // 'i' makes the search case-insensitive\n            if (regex.test(textNode.textContent as string)) {\n\n                // Get parent, test if it's a link \n                let parent: Node | null = textNode.parentNode;\n                if (parent && parent.nodeName !== 'A') {\n\n                    let frag: DocumentFragment = document.createDocumentFragment();\n                    let lastIndex: number = 0;\n                    let match: RegExpExecArray | null;\n                    regex.lastIndex = 0; // Reset the regex, because \".test()\" changes the lastIndex\n    \n                    while (match = regex.exec(textNode.textContent as string)) {\n\n                        if (!textNode.textContent) continue; \n\n                        let text: string = textNode.textContent.substring(lastIndex, match.index);\n                        frag.appendChild(document.createTextNode(text));\n    \n                        let link: HTMLAnchorElement = document.createElement('a');\n                        link.textContent = match[0]; // Use the matched text, which may include extra spaces\n                        link.href = linkTrackingUrl;\n                        link.target = \"_blank\";\n                        frag.appendChild(link);\n    \n                        lastIndex = regex.lastIndex;\n                    }\n    \n                    if (!textNode.textContent) continue; \n\n                    frag.appendChild(\n                        document.createTextNode(textNode.textContent.substr(lastIndex))\n                    ); \n                    parent.replaceChild(frag, textNode);\n\n                } else if(parent) {\n\n                    // If there is a parent A already, we override its Url \n                    (parent as HTMLAnchorElement).setAttribute(\"href\", linkTrackingUrl); \n                    (parent as HTMLAnchorElement).setAttribute(\"target\", \"_blank\"); \n\n                }\n    \n            }\n\n        }\n    }\n    \n    // Linkify rich text content in one element\n    linkifyRichText(rtfElement: Element, url: AdjustTrackingUrl): void {\n    \n        this.linkifyRichTextImages(\n            rtfElement, url\n            ); \n        this.linkifyRichTextRISE(\n            rtfElement, url\n            );\n    \n    }\n    \n    // Linkify all rich text elements\n    linkifyAllRichText(elemSelector: string) { \n\n        // Create and resolve Adjust tracking url\n        var url: AdjustTrackingUrl = new AdjustTrackingUrl(); \n        if (Rise.adjustTrackingUrl)\n            url = Rise.adjustTrackingUrl(url);\n        else {\n            console.error (\"No Adjust tracking handler\");\n            return; // do not linkify \n        }\n\n        // Get all elements with the selector\n        var richTextElements = document.querySelectorAll(elemSelector);\n\n        // Exit, if nothing found\n        if(!richTextElements) {\n            console.warn (\"No rich text elements found to linkify.\");\n            return;\n        }\n\n        // Iterate through each element\n        richTextElements.forEach((element: Element) => {\n\n            if(!element)\n                return;\n\n            // Linkify the identified rich text element\n            this.linkifyRichText(element, url); \n        \n        });\n    \n    }\n*/\n}\n\n    \n    \n\n    \n    \n    \n    "],
  "mappings": ";;AAUA,SAAO,WAAW,OAAO,YAAY,CAAC;AACtC,MAAI,QAAQ,OAAO;AAEZ,MAAM,SAAN,MAAa;AAAA,IAEhB,cAAc;AAAA,IACd;AAAA,IAEA,OAAO;AAEH,aAAO,kBAAkB,OAAO,mBAAmB,CAAC;AACpD,aAAO,gBAAgB,KAAK;AAAA,QAC1B;AAAA,QACA,CAAC,kBAAkB;AAEjB,kBAAQ,IAAI,8BAA8B;AAG1C,gBAAM,CAAC,YAAY,IAAI;AAEvB,kBAAQ,IAAI,YAAY;AACxB,cAAG,CAAC;AAAc;AAElB,kBAAQ,IAAI,aAAa,eAAe,MAAM;AAE9C,kBAAQ,IAAI,qBAAqB,cAAc,OAAO,MAAM;AAE5D,cAAI,gBAAgB,aAAa,OAAO;AACpC,oBAAQ,IAAI,QAAQ,cAAc,MAAM,EAAE;AAC1C,oBAAQ,IAAI,QAAQ,cAAc,MAAM,EAAE;AAAA,UAC9C;AAGA,uBAAa,GAAG,eAAe,CAAC,kBAAkB;AAEhD,oBAAQ,IAAI,WAAW,aAAa;AAAA,UACtC,CAAC;AAGD,uBAAa,GAAG,YAAY,CAAC,eAAe;AAC1C,oBAAQ,IAAI,WAAW,+DAA+D,UAAU;AAAA,UAClG,CAAC;AAED,kBAAQ,IAAI,cAAc;AAAA,QAE5B;AAAA,MACF,CAAC;AAED,aAAO,kBAAkB,OAAO,mBAAmB,CAAC;AACpD,aAAO,gBAAgB,KAAK;AAAA,QAC1B;AAAA,QACA,CAAC,oBAAoB;AAEnB,kBAAQ,IAAI,gCAAgC;AAG5C,gBAAM,CAAC,cAAc,IAAI;AAEzB,kBAAQ,IAAI,cAAc;AAC1B,cAAG,CAAC;AAAgB;AAEpB,kBAAQ,IAAI,qBAAqB,eAAe,cAAc,OAAO,MAAM;AAG3E,yBAAe,aAAa,GAAG,eAAe,CAAC,kBAAkB;AAG/D,oBAAQ,IAAI,aAAa,aAAa;AAAA,UACxC,CAAC;AAGD,yBAAe,aAAa,GAAG,YAAY,CAAC,eAAe;AACzD,oBAAQ,IAAI,aAAa,+DAA+D,UAAU;AAAA,UACpG,CAAC;AAEK,yBAAe,aAAa,GAAG,cAAc,CAAC,eAAe;AAC/D,oBAAQ,IAAI,aAAa,oBAAoB,8CAA8C,UAAU;AAAA,UACvG,CAAC;AAAA,QACL;AAAA,MACF,CAAC;AAAA,IAEL;AAAA,EAgKJ;",
  "names": []
}
